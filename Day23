#include <stdio.h>
#include <stdlib.h>

// Deque implementation using array
typedef struct {
    int *data;
    int front, rear, size, capacity;
} Deque;

// Function to create deque
Deque* createDeque(int capacity) {
    Deque* dq = (Deque*)malloc(sizeof(Deque));
    dq->capacity = capacity;
    dq->data = (int*)malloc(capacity * sizeof(int));
    dq->front = 0;
    dq->rear = -1;
    dq->size = 0;
    return dq;
}

// Check if deque is empty
int isEmpty(Deque* dq) {
    return dq->size == 0;
}

// Push element at rear
void pushBack(Deque* dq, int val) {
    dq->rear = (dq->rear + 1) % dq->capacity;
    dq->data[dq->rear] = val;
    dq->size++;
}

// Pop element from rear
void popBack(Deque* dq) {
    dq->rear = (dq->rear - 1 + dq->capacity) % dq->capacity;
    dq->size--;
}

// Pop element from front
void popFront(Deque* dq) {
    dq->front = (dq->front + 1) % dq->capacity;
    dq->size--;
}

// Get front element
int front(Deque* dq) {
    return dq->data[dq->front];
}

// Get rear element
int back(Deque* dq) {
    return dq->data[dq->rear];
}

// Function to find maximum in each sliding window
void slidingWindowMaximum(int arr[], int n, int k) {
    Deque* dq = createDeque(n);
    int i;

    for (i = 0; i < n; i++) {
        // Remove indices out of current window
        if (!isEmpty(dq) && front(dq) <= i - k) {
            popFront(dq);
        }

        // Remove smaller elements from rear
        while (!isEmpty(dq) && arr[back(dq)] <= arr[i]) {
            popBack(dq);
        }

        // Add current element index
        pushBack(dq, i);

        // Print max of current window
        if (i >= k - 1) {
            printf("%d ", arr[front(dq)]);
        }
    }
    printf("\n");

    free(dq->data);
    free(dq);
}

// Driver code
int main() {
    int arr1[] = {1, 3, -1, -3, 5, 3, 6, 7};
    int n1 = sizeof(arr1) / sizeof(arr1[0]);
    int k1 = 3;
    slidingWindowMaximum(arr1, n1, k1); // Output: 3 3 5 5 6 7

    int arr2[] = {1, 5, 3, 2, 4, 6};
    int n2 = sizeof(arr2) / sizeof(arr2[0]);
    int k2 = 3;
    slidingWindowMaximum(arr2, n2, k2); // Output: 5 5 4 6

    int arr3[] = {1, 2, 3, 4};
    int n3 = sizeof(arr3) / sizeof(arr3[0]);
    int k3 = 2;
    slidingWindowMaximum(arr3, n3, k3); // Output: 2 3 4

    int arr4[] = {7, 7, 7, 7};
    int n4 = sizeof(arr4) / sizeof(arr4[0]);
    int k4 = 1;
    slidingWindowMaximum(arr4, n4, k4); // Output: 7 7 7 7

    return 0;
}
